\documentclass{article}

% set font encoding for PDFLaTeX, XeLaTeX, or LuaTeX
\usepackage{ifxetex,ifluatex,amsmath}
\if\ifxetex T\else\ifluatex T\else F\fi\fi T%
  \usepackage{fontspec}
\else
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{lmodern}
\fi

\usepackage{hyperref}
%Import physics package
\usepackage{physics,mathtools}
%import syntax package
\usepackage{listings, listings-rust}
%Formats URL's
\usepackage{url}
%Draw stuff
\usepackage{tikz}
%For linking to images
\usepackage{caption}

\title{PWS/Meesterproef vloeistofdynamica}
\author{Wiebe Derksen and DaniÃ«l Visser}


\begin{document}
\maketitle
\thispagestyle{empty}
\hfil
\thanks{PWS begeleiders meneer Straatman en meneer Matena, expertbegeleider Aron Van Den Bogaard}
\newpage
\tableofcontents
\newpage
%Start van het PWS zelf
\section{Introduction}
People have been simulating liquids and gasses for decades using computers.
\newpage

\section{The Navier-Stokes equations}
The Navier Stokes equations are \cite{Navier Stokes compressible}:
\begin{equation}
%x-component
\begin{multlined}
\rho (\pdv{u}{t} + u \pdv{u}{x} + v \pdv{u}{y}+w\pdv{u}{z}) \\ = \rho g_{x}-\pdv{P}{x}+\pdv{x} \bqty{2\mu \pdv{u}{x} + \lambda div \vec{V}}\\ + \pdv{y} \bqty{\mu(\pdv{u}{y}+\pdv{v}{z})}+\pdv{z} \bqty{\mu (\pdv{u}{z}+\pdv{w}{x})}
\end{multlined}
\label{NSE-x}
\end{equation}

%y-component
\begin{equation}
\begin{split}
\rho(\pdv{v}{t}&+u\pdv{v}{x}+v\pdv{v}{y}+w\pdv{v}{z}) \\&=\rho g_{y} -\pdv{P}{y} +\pdv{x} \bqty{\mu(\pdv{u}{y}+\pdv{v}{x})}\\&+ \pdv{y} \bqty{2\mu \pdv{v}{y} + \lambda div\vec{V}} +\pdv{z} \bqty{\mu(\pdv{v}{z}+\pdv{w}{y})}
\end{split}
\label{NSE-y}
\end{equation}

%z-component
\begin{equation}
\begin{split}
\rho (\pdv{v}{t}& + u \pdv{w}{x} + v \pdv{w}{y} +  w \pdv{w}{x}) \\&= \rho g_{z} - \pdv{P}{z} + \pdv{x} \bqty{\mu(\pdv{u}{z}+\pdv{w}{x})}+\\ &\pdv{y}\bqty{\mu (\pdv{v}{z}+\pdv{w}{y})} +\pdv{x} 2\mu  \pdv{w}{y}+\lambda div \vec(V)
\label{NSE-z}
\end{split}
\end{equation}

\newpage
\section{What algorithms are feasible to implement?}
\subsection{Introduction to differential equations}
There are many algorithms to execute fluid simulations, each has its own advantages and disadvantages. In this chapter we will discuss these algorithms and their pro's and cons. 
\\

A differential equation can be solved either numerically or analytically. An analytical solution is a solution for the entire domain of the function. A numerical solution only gives an approximation for some discrete values.  Many differential equations are not analytically solvable, they have to be solved numerically. A numerical solution is often obtained using computers. \cite{What is discretization}




%Algorithms
\subsection{The algorithms}
In this section we will discuss some of the most used algorithms for solving the Navier-Stokes Equations, their advantages and disadvantages. 
%FDM
\subsubsection{Finite Difference Method(FDM)}
The Finite Difference Method(FDM) approximates the derivatives of a function using a truncated Taylor series. For a Taylor series around a point x=a the following formula applies. :\cite{Taylor series}:
\[f(x)=\sum_{i=0}^{\infty}\frac{f^{(i)}}{i!}(x-a)^{i}\]
A computer cannot keep computing forever. Therefore we have to use a truncated Taylor series. The truncated Taylor series unto i=3 is given by \cite{Taylor series approximation}
\[f(x)=f(a)+f'(a)(x-a)+\frac{f``(a)(x-a)^{2}}{2} + \frac{f^{(3)}(a)(x-a)^{3}}{6}+O(\Delta x)^{4}\]
$O(\Delta x) ^{4}$ are the truncated terms.\cite{Big O}. Using the above formula, we can calculate $f(x+\Delta x)$ by taking a=x\cite{quantstart FDM}
\begin{equation}f(x+\Delta x)=f(x)+f`(x)\Delta x + \frac{f``(x) (\Delta x)^{2}}{2}+ \frac{f^{(3)} (\Delta x)^{3}}{6} + O(\Delta x)^{4}\label{eqn:x plus deltax}\end{equation}
In the same way we can calculate $f(x-\Delta x)$:
\begin{equation}f(x- \Delta x)=f(x)-f`(x)\Delta x + \frac{f``(x)(\Delta x)^{2}}{2}-\frac{f^{(3)}(x)*(\Delta x)^{3}}{6} + O(\Delta x) ^{4} \label{eqn:x min deltax}\end{equation}
Using equation \ref{eqn:x plus deltax} we can approximate f'(x):
\[f(x+\Delta x) -f(x) = f'(x)\Delta x + O(x)^{2}\]
\[f`(x)=\frac{f(x+\Delta x) - f(x)}{\Delta x} + O(\Delta x)\]
$O(x)^{2}$ changes in $O(x)$ if it is divided by $\Delta x $. The equation above is called a first order approximation , because the lowest power in the big O is 1. The lowest power of the big O of a second order approximation is 2. $O(\Delta x)^{n}$ decreases to zero when $\Delta x$ becomes smaller, because $O(\Delta x)^{n}$ consists only of powers of $\Delta x$. The higher the lowest power, the fastest $O(\Delta x)^{n}$ declines and the better the derivative is approximated. We can calculate the second order approximation using equations \ref{eqn:x plus deltax} and \ref{eqn:x min deltax}
\begin{equation}f'(x)=\frac{f(x+\Delta x)-f(x-\Delta x)}{2\Delta x}\label{taylor deriative}\end{equation}
We can also use \ref{eqn:x plus deltax} and \ref{eqn:x min deltax} to calculate the second approximation of the second derivative.
\[f''(x)=\frac{f(x+\Delta x)-2f(x)+f(x-\Delta x)}{(\Delta x)^{2}}\]
Equation \ref{taylor deriative} can be used to turn equations \ref{NSE-x} , \ref{NSE-y} and \ref{NSE-z} into a set of equations without deriatives. The values of these equations can be calculated. 
%TODO: check whether they are linear or not -WD
%FEM
\subsubsection{Finite Element Method(FEM)}
The Finite Element Method(FEM) is a commonly used to solve differential equations. It has a lot of applications, CFD's being only one of them. Unlike the FDM the FEM does not solve the equations for only a few points, but for the entire domain. It does so by approximating the differential equation with linear subfunctions. The linear subfunctions will have unknown coefficients. These coefficients are put into a matrix.
%FVM
\subsubsection{Finite Volume Method(FVM)}
The finite volume method calculates the movement of "fluid particles". These particles are discretized points of a certain volume.\cite{Finite Volume} Therefore the FVM gives the exact expression for the average value of the solution (over the hence described volume). For each volume there is a flow in (Diffusion), a flow out (Convection), a transient term(the disturbance of the volume) and a source term resulting in the formula below.
\[\pdv{\rho\phi}{t} + \nabla \cdot (\rho\boldsymbol{v}\phi) = \nabla \cdot (\Gamma^\phi\nabla\phi) + Q^\phi\]
%Spectral Element method
\subsubsection{Spectral Element Method}
The spectral element method is a solution to the partial differentiation equation derived from the finite element method.
%Latice Boltzmann Method
\subsubsection{Lattice Boltzmann Method}
The Lattice Boltzmann Method models liquids as if the liquid exists of a n number of fictive particles. The method divides the simulation in two interchanging steps, collision and streaming. The steps change the density $\rho{(\vec{x},t)}$ at position $\vec{x}$ at time t. Because the Lattice Boltzmann method works within a lattice (a grid with a n amount of points in a m number of dimensions), you can draw up a formula $f_{i}(\vec{x},t)$. In this formula $f_{i}$ is the the influence of a neighbouring point i on $\vec{x}$ (a point on the lattice). The total movement vector in a point then becomes: \[P_{i}(\vec{x},t) = \sum_{i=0}^{a}f_{i}(\vec{x},t)\] Where a is the number of adjacent points on the lattice and P the total movement of the particle.
\paragraph{Collision} %Misschien handig om uit te leggen wat een lattice is. 
For simulating the collision of particles within the lattice, the formula is \cite{Lattice Boltzmann implementation}:
\[f_{i}(\vec{x}, t + \delta_t) = f_{i}(\vec{x}, t) + \frac{f_{i}^{eq}(\vec{x},t) - f_{i}(\vec{x},t)}{\tau_{f}}\]
$f_{i}(\vec{x}, t + \delta_t)$ is the influence at time $t + \delta_t$ with $\delta_t$ the size of the time step. A smaller $\delta_t$leads to a more accurate simulation but also lead to more computing time required to simulate a certain situation. \\
$\tau_{f}$ is a constant that depends on the viscosity of the simulated liquid. $f_{i}^{eq}(\vec{x},t)$ is the equilibrium density.
\paragraph{Streaming}
For simulating the actual movement of the particles the formula is: 
\[f_{i}(\vec{x}+\vec{e_i},t + \delta_t) = f_{i}(\vec{x},t)\]
Here $f_{i}(\vec{x}+\vec{e_i},t + \delta_t)$ is the fluid density at point $\vec{x}$ and $\vec{e}$ is the movement vector(the change in perceived density) of the density.
%Boundary Element Method
\subsubsection{Boundary Element Method}
The boundary element method is a method of simulating fluid dynamics with the presence of a influence of the boundary of the simulation, on the simulation. For this reason the boundary element method is quite complex and not really in the scope of this project. \cite{Boundary Element Method}
%Turbulence Methods
\subsubsection{Turbulence methods}
Apart from the above mentioned methods, there are also turbulence methods. These methods are able to simulate turbulent flows of liquids. These methods use a huge amount of computing power and thus are not really feasible for this paper.
%Some Choices
\subsection{Some Choices}
Due to the finite difference method being relatively easy to implement, we have decided to start our simulation by implementing that method. For a programming language we have chosen (provisionally) for Rust as it is fast and reasonably easy.
%Neglections
\subsection{Neglections in the Navier Stokes Equations}
\subsubsection{The dimension}
It is easier for computers to solve a 2D problem than a 3D problem, because for a 2D problem the number of grid points is smaller then for a 3D problem. For example, a 10 by 10 grid contains 100 points, while a 10 by 10 by 10 grid contains 1000 points. Furthermore, 2D rendering is easier then 3D rendering. However, nowadays computers are very fast. Therefore, our computers will be able to solve 3D problems. Since we intend to simulate a container with water, we will do a 3D simulation.
\subsubsection{Compressible and incompressible Navier Stokes Equations}
All fluids can be compressed. Their volume gets smaller when the pressure on the gas or fluid increases. However, in many cases the change in volume is not significant, then the flows can be approximated as incompressible flows. The Navier Stokes Equations can be simplified to the incompressible Navier Stokes Equations when a fluid is not compressible. Water is not very compressible\cite{NSE features}, so we will use the incompressible Navier Stokes Equations. The incompressible Navier Stokes equations for a Newtonian fluid, such as water, are:\cite{Navier Stokes incompressible} \cite{NASA NSE}
\begin{equation}
\begin{aligned}
&\pdv{v_{x}}{x}+\pdv{v_{y}}{y}+\pdv{v_{z}}{z}=0\\
&\left(\frac{\partial v_{\mathrm{x}}}{\partial t}+\frac{\partial v_{\mathrm{x}}}{\partial x} v_{\mathrm{x}}+\frac{\partial v_{\mathrm{x}}}{\partial y} v_{\mathrm{y}}+\frac{\partial v_{\mathrm{x}}}{\partial z} v_{\mathrm{z}}\right) \rho=-\frac{\partial p}{\partial x}+\eta\left(\frac{\partial^{2} v_{\mathrm{x}}}{\partial x^{2}}+\frac{\partial^{2} v_{\mathrm{x}}}{\partial y^{2}}+\frac{\partial^{2} v_{\mathrm{x}}}{\partial z^{2}}\right)+\rho g_{\mathrm{x}}\\
&\left(\frac{\partial v_{\mathrm{y}}}{\partial t}+\frac{\partial v_{\mathrm{y}}}{\partial x} v_{\mathrm{x}}+\frac{\partial v_{\mathrm{y}}}{\partial y} v_{\mathrm{y}}+\frac{\partial v_{\mathrm{y}}}{\partial z} v_{\mathrm{z}}\right) \rho=-\frac{\partial p}{\partial y}+\eta\left(\frac{\partial^{2} v_{\mathrm{y}}}{\partial x^{2}}+\frac{\partial^{2} v_{\mathrm{y}}}{\partial y^{2}}+\frac{\partial^{2} v_{\mathrm{y}}}{\partial z^{2}}\right)+\rho g_{\mathrm{y}}\\
&\left . \left(\frac{\partial v_{\mathrm{z}}}{\partial t}+\frac{\partial v_{\mathrm{z}}}{\partial x} v_{\mathrm{x}}+\frac{\partial v_{\mathrm{z}}}{\partial y} v_{\mathrm{y}}+\frac{\partial v_{\mathrm{z}}}{\partial z} v_{\mathrm{z}}\right) \rho=-\frac{\partial p}{\partial z}+\eta\left(\frac{\partial^{2} v_{\mathrm{z}}}{\partial x^{2}}+\frac{\partial^{2} v_{\mathrm{z}}}{\partial y^{2}}+\frac{\partial^{2} v_{\mathrm{z}}}{\partial z^{2}}\right)+\rho g_{\mathrm{z}}\right .
\end{aligned}
\label{NSE compressible}
\end{equation}
The equation at the top is called the continuity equation. The others are the momentum equations.
\subsubsection{Viscosity}
All fluids have viscosity. But, like compressibility, it can be neglected sometimes. Viscosity is: \(\eta=\frac{F/A}{dv_{x}/dz }\). Here F is the shear force, that is the force parallel to a surface. A is the surface and \(dv_{x}/dz\) is the change in velocity.\cite{Viscosity}. We will not neglect viscosity, because we do intend to simulate a water container with boundaries and viscosity is important near the boundaries, because there is dissipation over there.\cite{NSE features} Dissipation is the conversion of some for of energy to heat energy\cite{Dissipation}. Without viscosity the Navier Stokes Equations reduce to the Euler Equations\cite{NSE features}.
\subsubsection{Laminar and Turbulent flows}
Flows can be either laminar or turbulent\cite{NSE features}. In laminar flows there is no disruption between adjacent layers, but in turbulent flows there is. Turbulent flows have chaotic paths and they swirl. The Navier Stokes Equations for laminar and turbulent flows are the same. But there are very small changes in pressure, velocity and temperature in turbulent flows, which should be dealt with. Although a turbulent flow can be modelled using the Navier Stokes Equations, this costs a lot of computation power due to the small changes.\cite{Turbulence} Therefore, they are often modelled in another way. The simulation of turbulent flows is beyond the scope of this project.
\subsubsection{Steady and unsteady} \label{(un)steady}
A flow is either steady or unsteady\cite{NSE features}. In a steady flow parameters, such as velocity, do not change over time. In a unsteady flow parameters can change over time.\cite{Steady and unsteady} We will simulate a unsteady flow, because we want that the water in the container is able to move.
%Boundary conditions
\subsection{Boundary conditions}
To solve a partial differential equation it is necessary to enforce boundary conditions. A container with water has two types of boundaries. One type are the walls and the floor. The other is the free surface of the water. The free surface is the surface where the water and air touch each other. The boundary condition at the free surface is trickier than that at the walls and floor, since the free surface can move, while the walls and floors can not. 
\subsubsection{No-slip boundary condition}
The no-slip boundary conditition supposes the velocity of a fluid that touches a solid is equal to the velocity of the solid \cite{no-slip boundary condition}.
\subsubsection{Free slip boundary condition}
The free-slip boundary condition presumes the velocity of the fluid perpendicular to the wall is zero, so the fluid can not move through the wall. But, it does not restrict the velocity parallel to the wall.\cite{free slip boundary condition} 
\subsubsection{Dynamic boundary condition}
The dynamic boundary condition assumes the pressure on the free surface must be constant.
\newpage
%Programming
\section{Programming}
\subsection{Grid}
At first we tried to allocate a three dimensional array on the stack, which didn't work as the stack is only 2Mb's large. So we allocate the array on the heap. We define the grid as a three dimensional array allocated on the heap (boxed).
\begin{lstlisting}[language=Rust, style=boxed]
const GRID_SIZE : [usize;3] = [500,500,500];
let grid = 
      Box<[[[f32;GRID_SIZE[2]];GRID_SIZE[1]];GRID_SIZE[0]]>
\end{lstlisting}
The mayor issue we have run into is that a three dimensional array takes op a lot of space. an array with a size of $1000^{3}$ takes up $1000^{3}*4*2$ bytes or approximately 8 Gigabytes($*4$ because a floating point is 4 bytes large and $*2$ because you need to store the current array and the future array).
\subsection{Iterating}
Time in computers is not continuous but discretized. Because of this, we have to iterate over timesteps.
\begin{lstlisting}[language=Rust, style=boxed]
let mut iterations : u32 = 10;
for _ in 0..iterations{
    update(&mut grid);
}
pub fn update(
  &mut : Box<[[[f32;GRID_SIZE[2]];GRID_SIZE[1]];GRID_SIZE[0]]>
){
//TODO: Do the actual simulation
  draw(grid);
}
\end{lstlisting}
\subsection{Drawing}
\subsubsection{Initialization}
In order to show the actual grid we need a way to draw the grid to the screen. We've decided to use Vulkan as we alreay knew a bit about it and it is quite fast.\cite{Vulkan} Vulkan draws to a surface/swapchain (a window or a mp4/mkv file). This drawing is done by a device (a GPU) which gets its data from a buffer of vertices.
\begin{lstlisting}[language=Rust, style=boxed]
let instance = unsafe{fns::create_instance()}
//The window handle is retrieved by the winit library to make things easier
let surface = unsafe{ash_window::create_surface(&instance, window)}
let device = unsafe{get_compatible_device(&instance)}
let swapchain = unsafe{create_swapchain(&instance,&device)}
\end{lstlisting}
test
\subsection{The implementation of the finite difference method}
\subsubsection{Odd-even decoupling}
%Image
\begin{figure}
\begin{tikzpicture}
%Collocated grid
\filldraw[fill=black!10!white, draw=black] (0,0) rectangle (1,1.168);
\node[] at (0.5,-0.2) {i-1};
\filldraw[fill=black!10!white, draw=black] (1,0) rectangle (2,1.5);
\node[] at (1.5,-0.2) {i};
\filldraw[fill=black!10!white, draw=black] (2,0) rectangle (3,1.168);
\node[] at (2.5,-0.2) {i+1};
\node[] at (1.5,-0.8) {Using a collocated grid};
%Staggered grid
\filldraw[fill=black!10!white, draw=black] (4,0) rectangle (5,1.168);
\node[] at (4.5,-0.2) {i-1};
\filldraw[fill=black!10!white, draw=black] (5,0) rectangle (6,1.5);
\node[] at (5.5,-0.2) {i};
\filldraw[fill=black!10!white, draw=black] (6,0) rectangle (7,1.168);
\node[] at (6.5,-0.2) {i+1};
\draw [red, stealth-] (4.7, 0.5) -- (5.3, 0.5);
\draw [red, -stealth] (5.7, 0.5) -- (6.3, 0.5);
\node[red] at (5,-0.5) {\(v_{i}\)};
\node[red] at (6,-0.5) {\(v_{i+1}\)};
\node[] at (5.5,-0.8) {Using a staggered grid};
\end{tikzpicture} \caption{} \label{Odd-even decoupling} \end{figure}
%Odd-even decoupling
The Finite Difference Method calculates the pressure and velocity at discrete grid points. We can choose ourselves which variables will be calculated at which points. It would be the most easy to store all variables at every point. Such a grid is called a collocated grid. However, as figure \ref{Odd-even decoupling} shows, there will be no fluid flow between cell i-1 and i and cell i and i+1 when the pressure in cells i-1 and i+1 is equal in such a grid. This happens because the derivative in cell i will be zero. To solve that problem we will use a staggered grid, such as in the right side of figure \ref{Odd-even decoupling}. A staggered grid consists of cells. The pressure is stored in the cell center and the velocities in the cell edges that are perpendicular to them.
\newpage
%Eind PWS, start bronnenlijst
\begin{thebibliography}{3}
\bibitem{Discretization types}
\url{https://resources.pcb.cadence.com/blog/2020-cfd-simulation-types-discretization-approximation-and-algorithms}
\bibitem{What is discretization}
\url{https://www.manchestercfd.co.uk/post/what-is-discretization}
\bibitem{Difference equation}
\url{https://www.britannica.com/science/difference-equation}
\bibitem{Taylor series}
\url{https://courses.engr.illinois.edu/cs357/fa2019/assets/lectures/Lecture8-Sept19.pdf}
\bibitem{Navier_Stokes_afleiding}
\url{https://web.iit.edu/sites/web/files/departments/academic-affairs/academic-resource-center/pdfs/Navier_Stokes.pdf}
\bibitem{Fluid simulation methods}
\url{https://www.dive-solutions.de/articles/cfd-methods}
\bibitem{Lattice Boltzmann implementation}
\url{https://arxiv.org/pdf/cs/0501021.pdf}
\bibitem{Taylor series approximation}
\url{https://brilliant.org/wiki/taylor-series-approximation/}
\bibitem{quantstart FDM}
\url{https://www.quantstart.com/articles/Derivative-Approximation-via-Finite-Difference-Methods/}
\bibitem{Big O}
\url{https://math.stackexchange.com/questions/501735/why-do-we-use-big-oh-in-taylor-series}
\bibitem{Maxwell FDM}
\url{https://maxwell.ict.griffith.edu.au/jl/Chapter5.pdf}
\bibitem{Boundary Element Method}
\url{https://pure.tue.nl/ws/files/3372975/696955.pdf}
\bibitem{Finite Element Method}
\url{https://www.comsol.com/multiphysics/finite-element-method}
\bibitem{Finite Volume}
\url{https://link.springer.com/chapter/10.1007\%2F978-3-319-16874-6\_19}
\bibitem{More_FDM}
\url{http://www.fem.unicamp.br/~phoenics/SITE_PHOENICS/Apostilas/CFD-1_U\%20Michigan_Hong/Lecture13.pdf}
\bibitem{no-slip boundary condition}
\url{https://www.quora.com/What-is-the-physics-behind-no-slip-condition-in-fluid-mechanics}
\bibitem{free slip boundary condition}
\url{https://physics.stackexchange.com/questions/383096/understanding-free-slip-boundary-condition}
%Begin of Navier-Stokes
\bibitem{Navier Stokes incompressible}
\url{https://www.tec-science.com/mechanics/gases-and-liquids/derivation-of-the-navier-stokes-equations/}
\bibitem{Stresses}
\url{https://www.paramvisions.com/2021/04/what-is-normal-stress-shear-stress.html}
\bibitem{Navier Stokes compressible}
\url{http://ingforum.haninge.kth.se/armin/fluid/exer/deriv_navier_stokes.pdf}
%Neglections
\bibitem{NSE features}
\url{https://projects.iq.harvard.edu/files/ac274_2015/files/lecture2_3.pdf}
\bibitem{Viscosity}
\url{https://physics.info/viscosity/}
\bibitem{Dissipation}
\url{https://www.tec-science.com/thermodynamics/thermodynamic-processes-in-closed-systems/what-is-meant-by-dissipation-of-energy/}
\bibitem{Turbulence}
\url{https://www.simscale.com/blog/2017/12/turbulence-cfd-analysis/}
\bibitem{Steady and unsteady}
\url{http://www.nzdl.org/cgi-bin/library?e=d-00000-00---off-0hdl--00-0----0-10-0---0---0direct-10---4-------0-1l--11-en-50---20-about---00-0-1-00-0--4----0-0-11-10-0utfZz-8-00\&cl=CL1.11\&d=HASH011f05bf8734d88d1a080257.12.1\&gt=1}
\bibitem{NASA NSE}
\url{https://www.grc.nasa.gov/WWW/k-12/airplane/nseqs.html}
%End of Navier Stokes
\bibitem{Vulkan}
https://vulkan-tutorial.com/
\end{thebibliography}
\end{document}
